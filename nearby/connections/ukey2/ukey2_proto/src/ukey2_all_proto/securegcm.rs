// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `securegcm.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GcmDeviceInfo {
    // message fields
    android_device_id: ::std::option::Option<u64>,
    gcm_registration_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    apn_registration_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    notification_enabled: ::std::option::Option<bool>,
    bluetooth_mac_address: ::protobuf::SingularField<::std::string::String>,
    device_master_key_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    user_public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    device_model: ::protobuf::SingularField<::std::string::String>,
    locale: ::protobuf::SingularField<::std::string::String>,
    key_handle: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    counter: ::std::option::Option<i64>,
    device_os_version: ::protobuf::SingularField<::std::string::String>,
    device_os_version_code: ::std::option::Option<i64>,
    device_os_release: ::protobuf::SingularField<::std::string::String>,
    device_os_codename: ::protobuf::SingularField<::std::string::String>,
    device_software_version: ::protobuf::SingularField<::std::string::String>,
    device_software_version_code: ::std::option::Option<i64>,
    device_software_package: ::protobuf::SingularField<::std::string::String>,
    device_display_diagonal_mils: ::std::option::Option<i32>,
    device_authzen_version: ::std::option::Option<i32>,
    long_device_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    device_manufacturer: ::protobuf::SingularField<::std::string::String>,
    device_type: ::std::option::Option<DeviceType>,
    using_secure_screenlock: ::std::option::Option<bool>,
    auto_unlock_screenlock_supported: ::std::option::Option<bool>,
    auto_unlock_screenlock_enabled: ::std::option::Option<bool>,
    bluetooth_radio_supported: ::std::option::Option<bool>,
    bluetooth_radio_enabled: ::std::option::Option<bool>,
    mobile_data_supported: ::std::option::Option<bool>,
    tethering_supported: ::std::option::Option<bool>,
    ble_radio_supported: ::std::option::Option<bool>,
    pixel_experience: ::std::option::Option<bool>,
    arc_plus_plus: ::std::option::Option<bool>,
    is_screenlock_state_flaky: ::std::option::Option<bool>,
    pub supported_software_features: ::std::vec::Vec<SoftwareFeature>,
    pub enabled_software_features: ::std::vec::Vec<SoftwareFeature>,
    enrollment_session_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    oauth_token: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcmDeviceInfo {
    fn default() -> &'a GcmDeviceInfo {
        <GcmDeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl GcmDeviceInfo {
    pub fn new() -> GcmDeviceInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 android_device_id = 1;


    pub fn get_android_device_id(&self) -> u64 {
        self.android_device_id.unwrap_or(0)
    }
    pub fn clear_android_device_id(&mut self) {
        self.android_device_id = ::std::option::Option::None;
    }

    pub fn has_android_device_id(&self) -> bool {
        self.android_device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_android_device_id(&mut self, v: u64) {
        self.android_device_id = ::std::option::Option::Some(v);
    }

    // optional bytes gcm_registration_id = 102;


    pub fn get_gcm_registration_id(&self) -> &[u8] {
        match self.gcm_registration_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_gcm_registration_id(&mut self) {
        self.gcm_registration_id.clear();
    }

    pub fn has_gcm_registration_id(&self) -> bool {
        self.gcm_registration_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcm_registration_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gcm_registration_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcm_registration_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gcm_registration_id.is_none() {
            self.gcm_registration_id.set_default();
        }
        self.gcm_registration_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcm_registration_id(&mut self) -> ::std::vec::Vec<u8> {
        self.gcm_registration_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes apn_registration_id = 202;


    pub fn get_apn_registration_id(&self) -> &[u8] {
        match self.apn_registration_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_apn_registration_id(&mut self) {
        self.apn_registration_id.clear();
    }

    pub fn has_apn_registration_id(&self) -> bool {
        self.apn_registration_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apn_registration_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.apn_registration_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apn_registration_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.apn_registration_id.is_none() {
            self.apn_registration_id.set_default();
        }
        self.apn_registration_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_apn_registration_id(&mut self) -> ::std::vec::Vec<u8> {
        self.apn_registration_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool notification_enabled = 203;


    pub fn get_notification_enabled(&self) -> bool {
        self.notification_enabled.unwrap_or(true)
    }
    pub fn clear_notification_enabled(&mut self) {
        self.notification_enabled = ::std::option::Option::None;
    }

    pub fn has_notification_enabled(&self) -> bool {
        self.notification_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_enabled(&mut self, v: bool) {
        self.notification_enabled = ::std::option::Option::Some(v);
    }

    // optional string bluetooth_mac_address = 302;


    pub fn get_bluetooth_mac_address(&self) -> &str {
        match self.bluetooth_mac_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bluetooth_mac_address(&mut self) {
        self.bluetooth_mac_address.clear();
    }

    pub fn has_bluetooth_mac_address(&self) -> bool {
        self.bluetooth_mac_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bluetooth_mac_address(&mut self, v: ::std::string::String) {
        self.bluetooth_mac_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bluetooth_mac_address(&mut self) -> &mut ::std::string::String {
        if self.bluetooth_mac_address.is_none() {
            self.bluetooth_mac_address.set_default();
        }
        self.bluetooth_mac_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_bluetooth_mac_address(&mut self) -> ::std::string::String {
        self.bluetooth_mac_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes device_master_key_hash = 103;


    pub fn get_device_master_key_hash(&self) -> &[u8] {
        match self.device_master_key_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_device_master_key_hash(&mut self) {
        self.device_master_key_hash.clear();
    }

    pub fn has_device_master_key_hash(&self) -> bool {
        self.device_master_key_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_master_key_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_master_key_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_master_key_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_master_key_hash.is_none() {
            self.device_master_key_hash.set_default();
        }
        self.device_master_key_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_master_key_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.device_master_key_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes user_public_key = 4;


    pub fn get_user_public_key(&self) -> &[u8] {
        match self.user_public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_user_public_key(&mut self) {
        self.user_public_key.clear();
    }

    pub fn has_user_public_key(&self) -> bool {
        self.user_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.user_public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.user_public_key.is_none() {
            self.user_public_key.set_default();
        }
        self.user_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.user_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string device_model = 7;


    pub fn get_device_model(&self) -> &str {
        match self.device_model.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_model(&mut self) {
        self.device_model.clear();
    }

    pub fn has_device_model(&self) -> bool {
        self.device_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_model(&mut self, v: ::std::string::String) {
        self.device_model = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_model(&mut self) -> &mut ::std::string::String {
        if self.device_model.is_none() {
            self.device_model.set_default();
        }
        self.device_model.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_model(&mut self) -> ::std::string::String {
        self.device_model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string locale = 8;


    pub fn get_locale(&self) -> &str {
        match self.locale.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_locale(&mut self) {
        self.locale.clear();
    }

    pub fn has_locale(&self) -> bool {
        self.locale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locale(&mut self, v: ::std::string::String) {
        self.locale = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locale(&mut self) -> &mut ::std::string::String {
        if self.locale.is_none() {
            self.locale.set_default();
        }
        self.locale.as_mut().unwrap()
    }

    // Take field
    pub fn take_locale(&mut self) -> ::std::string::String {
        self.locale.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes key_handle = 9;


    pub fn get_key_handle(&self) -> &[u8] {
        match self.key_handle.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key_handle(&mut self) {
        self.key_handle.clear();
    }

    pub fn has_key_handle(&self) -> bool {
        self.key_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_handle(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_handle = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_handle(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_handle.is_none() {
            self.key_handle.set_default();
        }
        self.key_handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_handle(&mut self) -> ::std::vec::Vec<u8> {
        self.key_handle.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 counter = 12;


    pub fn get_counter(&self) -> i64 {
        self.counter.unwrap_or(0i64)
    }
    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: i64) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional string device_os_version = 13;


    pub fn get_device_os_version(&self) -> &str {
        match self.device_os_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_os_version(&mut self) {
        self.device_os_version.clear();
    }

    pub fn has_device_os_version(&self) -> bool {
        self.device_os_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_os_version(&mut self, v: ::std::string::String) {
        self.device_os_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_os_version(&mut self) -> &mut ::std::string::String {
        if self.device_os_version.is_none() {
            self.device_os_version.set_default();
        }
        self.device_os_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_os_version(&mut self) -> ::std::string::String {
        self.device_os_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 device_os_version_code = 14;


    pub fn get_device_os_version_code(&self) -> i64 {
        self.device_os_version_code.unwrap_or(0)
    }
    pub fn clear_device_os_version_code(&mut self) {
        self.device_os_version_code = ::std::option::Option::None;
    }

    pub fn has_device_os_version_code(&self) -> bool {
        self.device_os_version_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_os_version_code(&mut self, v: i64) {
        self.device_os_version_code = ::std::option::Option::Some(v);
    }

    // optional string device_os_release = 15;


    pub fn get_device_os_release(&self) -> &str {
        match self.device_os_release.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_os_release(&mut self) {
        self.device_os_release.clear();
    }

    pub fn has_device_os_release(&self) -> bool {
        self.device_os_release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_os_release(&mut self, v: ::std::string::String) {
        self.device_os_release = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_os_release(&mut self) -> &mut ::std::string::String {
        if self.device_os_release.is_none() {
            self.device_os_release.set_default();
        }
        self.device_os_release.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_os_release(&mut self) -> ::std::string::String {
        self.device_os_release.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device_os_codename = 16;


    pub fn get_device_os_codename(&self) -> &str {
        match self.device_os_codename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_os_codename(&mut self) {
        self.device_os_codename.clear();
    }

    pub fn has_device_os_codename(&self) -> bool {
        self.device_os_codename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_os_codename(&mut self, v: ::std::string::String) {
        self.device_os_codename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_os_codename(&mut self) -> &mut ::std::string::String {
        if self.device_os_codename.is_none() {
            self.device_os_codename.set_default();
        }
        self.device_os_codename.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_os_codename(&mut self) -> ::std::string::String {
        self.device_os_codename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device_software_version = 17;


    pub fn get_device_software_version(&self) -> &str {
        match self.device_software_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_software_version(&mut self) {
        self.device_software_version.clear();
    }

    pub fn has_device_software_version(&self) -> bool {
        self.device_software_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_software_version(&mut self, v: ::std::string::String) {
        self.device_software_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_software_version(&mut self) -> &mut ::std::string::String {
        if self.device_software_version.is_none() {
            self.device_software_version.set_default();
        }
        self.device_software_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_software_version(&mut self) -> ::std::string::String {
        self.device_software_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 device_software_version_code = 18;


    pub fn get_device_software_version_code(&self) -> i64 {
        self.device_software_version_code.unwrap_or(0)
    }
    pub fn clear_device_software_version_code(&mut self) {
        self.device_software_version_code = ::std::option::Option::None;
    }

    pub fn has_device_software_version_code(&self) -> bool {
        self.device_software_version_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_software_version_code(&mut self, v: i64) {
        self.device_software_version_code = ::std::option::Option::Some(v);
    }

    // optional string device_software_package = 19;


    pub fn get_device_software_package(&self) -> &str {
        match self.device_software_package.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_software_package(&mut self) {
        self.device_software_package.clear();
    }

    pub fn has_device_software_package(&self) -> bool {
        self.device_software_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_software_package(&mut self, v: ::std::string::String) {
        self.device_software_package = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_software_package(&mut self) -> &mut ::std::string::String {
        if self.device_software_package.is_none() {
            self.device_software_package.set_default();
        }
        self.device_software_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_software_package(&mut self) -> ::std::string::String {
        self.device_software_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 device_display_diagonal_mils = 22;


    pub fn get_device_display_diagonal_mils(&self) -> i32 {
        self.device_display_diagonal_mils.unwrap_or(0)
    }
    pub fn clear_device_display_diagonal_mils(&mut self) {
        self.device_display_diagonal_mils = ::std::option::Option::None;
    }

    pub fn has_device_display_diagonal_mils(&self) -> bool {
        self.device_display_diagonal_mils.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_display_diagonal_mils(&mut self, v: i32) {
        self.device_display_diagonal_mils = ::std::option::Option::Some(v);
    }

    // optional int32 device_authzen_version = 24;


    pub fn get_device_authzen_version(&self) -> i32 {
        self.device_authzen_version.unwrap_or(0)
    }
    pub fn clear_device_authzen_version(&mut self) {
        self.device_authzen_version = ::std::option::Option::None;
    }

    pub fn has_device_authzen_version(&self) -> bool {
        self.device_authzen_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_authzen_version(&mut self, v: i32) {
        self.device_authzen_version = ::std::option::Option::Some(v);
    }

    // optional bytes long_device_id = 29;


    pub fn get_long_device_id(&self) -> &[u8] {
        match self.long_device_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_long_device_id(&mut self) {
        self.long_device_id.clear();
    }

    pub fn has_long_device_id(&self) -> bool {
        self.long_device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_long_device_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.long_device_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_long_device_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.long_device_id.is_none() {
            self.long_device_id.set_default();
        }
        self.long_device_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_long_device_id(&mut self) -> ::std::vec::Vec<u8> {
        self.long_device_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string device_manufacturer = 31;


    pub fn get_device_manufacturer(&self) -> &str {
        match self.device_manufacturer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_manufacturer(&mut self) {
        self.device_manufacturer.clear();
    }

    pub fn has_device_manufacturer(&self) -> bool {
        self.device_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_manufacturer(&mut self, v: ::std::string::String) {
        self.device_manufacturer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.device_manufacturer.is_none() {
            self.device_manufacturer.set_default();
        }
        self.device_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_manufacturer(&mut self) -> ::std::string::String {
        self.device_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .securegcm.DeviceType device_type = 32;


    pub fn get_device_type(&self) -> DeviceType {
        self.device_type.unwrap_or(DeviceType::ANDROID)
    }
    pub fn clear_device_type(&mut self) {
        self.device_type = ::std::option::Option::None;
    }

    pub fn has_device_type(&self) -> bool {
        self.device_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_type(&mut self, v: DeviceType) {
        self.device_type = ::std::option::Option::Some(v);
    }

    // optional bool using_secure_screenlock = 400;


    pub fn get_using_secure_screenlock(&self) -> bool {
        self.using_secure_screenlock.unwrap_or(false)
    }
    pub fn clear_using_secure_screenlock(&mut self) {
        self.using_secure_screenlock = ::std::option::Option::None;
    }

    pub fn has_using_secure_screenlock(&self) -> bool {
        self.using_secure_screenlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_using_secure_screenlock(&mut self, v: bool) {
        self.using_secure_screenlock = ::std::option::Option::Some(v);
    }

    // optional bool auto_unlock_screenlock_supported = 401;


    pub fn get_auto_unlock_screenlock_supported(&self) -> bool {
        self.auto_unlock_screenlock_supported.unwrap_or(false)
    }
    pub fn clear_auto_unlock_screenlock_supported(&mut self) {
        self.auto_unlock_screenlock_supported = ::std::option::Option::None;
    }

    pub fn has_auto_unlock_screenlock_supported(&self) -> bool {
        self.auto_unlock_screenlock_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_unlock_screenlock_supported(&mut self, v: bool) {
        self.auto_unlock_screenlock_supported = ::std::option::Option::Some(v);
    }

    // optional bool auto_unlock_screenlock_enabled = 402;


    pub fn get_auto_unlock_screenlock_enabled(&self) -> bool {
        self.auto_unlock_screenlock_enabled.unwrap_or(false)
    }
    pub fn clear_auto_unlock_screenlock_enabled(&mut self) {
        self.auto_unlock_screenlock_enabled = ::std::option::Option::None;
    }

    pub fn has_auto_unlock_screenlock_enabled(&self) -> bool {
        self.auto_unlock_screenlock_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_unlock_screenlock_enabled(&mut self, v: bool) {
        self.auto_unlock_screenlock_enabled = ::std::option::Option::Some(v);
    }

    // optional bool bluetooth_radio_supported = 403;


    pub fn get_bluetooth_radio_supported(&self) -> bool {
        self.bluetooth_radio_supported.unwrap_or(false)
    }
    pub fn clear_bluetooth_radio_supported(&mut self) {
        self.bluetooth_radio_supported = ::std::option::Option::None;
    }

    pub fn has_bluetooth_radio_supported(&self) -> bool {
        self.bluetooth_radio_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bluetooth_radio_supported(&mut self, v: bool) {
        self.bluetooth_radio_supported = ::std::option::Option::Some(v);
    }

    // optional bool bluetooth_radio_enabled = 404;


    pub fn get_bluetooth_radio_enabled(&self) -> bool {
        self.bluetooth_radio_enabled.unwrap_or(false)
    }
    pub fn clear_bluetooth_radio_enabled(&mut self) {
        self.bluetooth_radio_enabled = ::std::option::Option::None;
    }

    pub fn has_bluetooth_radio_enabled(&self) -> bool {
        self.bluetooth_radio_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bluetooth_radio_enabled(&mut self, v: bool) {
        self.bluetooth_radio_enabled = ::std::option::Option::Some(v);
    }

    // optional bool mobile_data_supported = 405;


    pub fn get_mobile_data_supported(&self) -> bool {
        self.mobile_data_supported.unwrap_or(false)
    }
    pub fn clear_mobile_data_supported(&mut self) {
        self.mobile_data_supported = ::std::option::Option::None;
    }

    pub fn has_mobile_data_supported(&self) -> bool {
        self.mobile_data_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_data_supported(&mut self, v: bool) {
        self.mobile_data_supported = ::std::option::Option::Some(v);
    }

    // optional bool tethering_supported = 406;


    pub fn get_tethering_supported(&self) -> bool {
        self.tethering_supported.unwrap_or(false)
    }
    pub fn clear_tethering_supported(&mut self) {
        self.tethering_supported = ::std::option::Option::None;
    }

    pub fn has_tethering_supported(&self) -> bool {
        self.tethering_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tethering_supported(&mut self, v: bool) {
        self.tethering_supported = ::std::option::Option::Some(v);
    }

    // optional bool ble_radio_supported = 407;


    pub fn get_ble_radio_supported(&self) -> bool {
        self.ble_radio_supported.unwrap_or(false)
    }
    pub fn clear_ble_radio_supported(&mut self) {
        self.ble_radio_supported = ::std::option::Option::None;
    }

    pub fn has_ble_radio_supported(&self) -> bool {
        self.ble_radio_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ble_radio_supported(&mut self, v: bool) {
        self.ble_radio_supported = ::std::option::Option::Some(v);
    }

    // optional bool pixel_experience = 408;


    pub fn get_pixel_experience(&self) -> bool {
        self.pixel_experience.unwrap_or(false)
    }
    pub fn clear_pixel_experience(&mut self) {
        self.pixel_experience = ::std::option::Option::None;
    }

    pub fn has_pixel_experience(&self) -> bool {
        self.pixel_experience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pixel_experience(&mut self, v: bool) {
        self.pixel_experience = ::std::option::Option::Some(v);
    }

    // optional bool arc_plus_plus = 409;


    pub fn get_arc_plus_plus(&self) -> bool {
        self.arc_plus_plus.unwrap_or(false)
    }
    pub fn clear_arc_plus_plus(&mut self) {
        self.arc_plus_plus = ::std::option::Option::None;
    }

    pub fn has_arc_plus_plus(&self) -> bool {
        self.arc_plus_plus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arc_plus_plus(&mut self, v: bool) {
        self.arc_plus_plus = ::std::option::Option::Some(v);
    }

    // optional bool is_screenlock_state_flaky = 410;


    pub fn get_is_screenlock_state_flaky(&self) -> bool {
        self.is_screenlock_state_flaky.unwrap_or(false)
    }
    pub fn clear_is_screenlock_state_flaky(&mut self) {
        self.is_screenlock_state_flaky = ::std::option::Option::None;
    }

    pub fn has_is_screenlock_state_flaky(&self) -> bool {
        self.is_screenlock_state_flaky.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_screenlock_state_flaky(&mut self, v: bool) {
        self.is_screenlock_state_flaky = ::std::option::Option::Some(v);
    }

    // repeated .securegcm.SoftwareFeature supported_software_features = 411;


    pub fn get_supported_software_features(&self) -> &[SoftwareFeature] {
        &self.supported_software_features
    }
    pub fn clear_supported_software_features(&mut self) {
        self.supported_software_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_software_features(&mut self, v: ::std::vec::Vec<SoftwareFeature>) {
        self.supported_software_features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_software_features(&mut self) -> &mut ::std::vec::Vec<SoftwareFeature> {
        &mut self.supported_software_features
    }

    // Take field
    pub fn take_supported_software_features(&mut self) -> ::std::vec::Vec<SoftwareFeature> {
        ::std::mem::replace(&mut self.supported_software_features, ::std::vec::Vec::new())
    }

    // repeated .securegcm.SoftwareFeature enabled_software_features = 412;


    pub fn get_enabled_software_features(&self) -> &[SoftwareFeature] {
        &self.enabled_software_features
    }
    pub fn clear_enabled_software_features(&mut self) {
        self.enabled_software_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_enabled_software_features(&mut self, v: ::std::vec::Vec<SoftwareFeature>) {
        self.enabled_software_features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enabled_software_features(&mut self) -> &mut ::std::vec::Vec<SoftwareFeature> {
        &mut self.enabled_software_features
    }

    // Take field
    pub fn take_enabled_software_features(&mut self) -> ::std::vec::Vec<SoftwareFeature> {
        ::std::mem::replace(&mut self.enabled_software_features, ::std::vec::Vec::new())
    }

    // optional bytes enrollment_session_id = 1000;


    pub fn get_enrollment_session_id(&self) -> &[u8] {
        match self.enrollment_session_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_enrollment_session_id(&mut self) {
        self.enrollment_session_id.clear();
    }

    pub fn has_enrollment_session_id(&self) -> bool {
        self.enrollment_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enrollment_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.enrollment_session_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enrollment_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.enrollment_session_id.is_none() {
            self.enrollment_session_id.set_default();
        }
        self.enrollment_session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_enrollment_session_id(&mut self) -> ::std::vec::Vec<u8> {
        self.enrollment_session_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string oauth_token = 1001;


    pub fn get_oauth_token(&self) -> &str {
        match self.oauth_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_oauth_token(&mut self) {
        self.oauth_token.clear();
    }

    pub fn has_oauth_token(&self) -> bool {
        self.oauth_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oauth_token(&mut self, v: ::std::string::String) {
        self.oauth_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oauth_token(&mut self) -> &mut ::std::string::String {
        if self.oauth_token.is_none() {
            self.oauth_token.set_default();
        }
        self.oauth_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_oauth_token(&mut self) -> ::std::string::String {
        self.oauth_token.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GcmDeviceInfo {
    fn is_initialized(&self) -> bool {
        if self.user_public_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.android_device_id = ::std::option::Option::Some(tmp);
                },
                102 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gcm_registration_id)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.apn_registration_id)?;
                },
                203 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notification_enabled = ::std::option::Option::Some(tmp);
                },
                302 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bluetooth_mac_address)?;
                },
                103 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.device_master_key_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.user_public_key)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_model)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.locale)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key_handle)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.counter = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_os_version)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.device_os_version_code = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_os_release)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_os_codename)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_software_version)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.device_software_version_code = ::std::option::Option::Some(tmp);
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_software_package)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_display_diagonal_mils = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_authzen_version = ::std::option::Option::Some(tmp);
                },
                29 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.long_device_id)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_manufacturer)?;
                },
                32 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.device_type, 32, &mut self.unknown_fields)?
                },
                400 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.using_secure_screenlock = ::std::option::Option::Some(tmp);
                },
                401 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.auto_unlock_screenlock_supported = ::std::option::Option::Some(tmp);
                },
                402 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.auto_unlock_screenlock_enabled = ::std::option::Option::Some(tmp);
                },
                403 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bluetooth_radio_supported = ::std::option::Option::Some(tmp);
                },
                404 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bluetooth_radio_enabled = ::std::option::Option::Some(tmp);
                },
                405 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mobile_data_supported = ::std::option::Option::Some(tmp);
                },
                406 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tethering_supported = ::std::option::Option::Some(tmp);
                },
                407 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ble_radio_supported = ::std::option::Option::Some(tmp);
                },
                408 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pixel_experience = ::std::option::Option::Some(tmp);
                },
                409 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.arc_plus_plus = ::std::option::Option::Some(tmp);
                },
                410 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_screenlock_state_flaky = ::std::option::Option::Some(tmp);
                },
                411 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_software_features, 411, &mut self.unknown_fields)?
                },
                412 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.enabled_software_features, 412, &mut self.unknown_fields)?
                },
                1000 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.enrollment_session_id)?;
                },
                1001 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.oauth_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.android_device_id {
            my_size += 9;
        }
        if let Some(ref v) = self.gcm_registration_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(102, &v);
        }
        if let Some(ref v) = self.apn_registration_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(202, &v);
        }
        if let Some(v) = self.notification_enabled {
            my_size += 3;
        }
        if let Some(ref v) = self.bluetooth_mac_address.as_ref() {
            my_size += ::protobuf::rt::string_size(302, &v);
        }
        if let Some(ref v) = self.device_master_key_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(103, &v);
        }
        if let Some(ref v) = self.user_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.device_model.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.locale.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.key_handle.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device_os_version.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.device_os_version_code {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device_os_release.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(ref v) = self.device_os_codename.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(ref v) = self.device_software_version.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.device_software_version_code {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device_software_package.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.device_display_diagonal_mils {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.device_authzen_version {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.long_device_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(29, &v);
        }
        if let Some(ref v) = self.device_manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(31, &v);
        }
        if let Some(v) = self.device_type {
            my_size += ::protobuf::rt::enum_size(32, v);
        }
        if let Some(v) = self.using_secure_screenlock {
            my_size += 3;
        }
        if let Some(v) = self.auto_unlock_screenlock_supported {
            my_size += 3;
        }
        if let Some(v) = self.auto_unlock_screenlock_enabled {
            my_size += 3;
        }
        if let Some(v) = self.bluetooth_radio_supported {
            my_size += 3;
        }
        if let Some(v) = self.bluetooth_radio_enabled {
            my_size += 3;
        }
        if let Some(v) = self.mobile_data_supported {
            my_size += 3;
        }
        if let Some(v) = self.tethering_supported {
            my_size += 3;
        }
        if let Some(v) = self.ble_radio_supported {
            my_size += 3;
        }
        if let Some(v) = self.pixel_experience {
            my_size += 3;
        }
        if let Some(v) = self.arc_plus_plus {
            my_size += 3;
        }
        if let Some(v) = self.is_screenlock_state_flaky {
            my_size += 3;
        }
        for value in &self.supported_software_features {
            my_size += ::protobuf::rt::enum_size(411, *value);
        };
        for value in &self.enabled_software_features {
            my_size += ::protobuf::rt::enum_size(412, *value);
        };
        if let Some(ref v) = self.enrollment_session_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1000, &v);
        }
        if let Some(ref v) = self.oauth_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1001, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.android_device_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.gcm_registration_id.as_ref() {
            os.write_bytes(102, &v)?;
        }
        if let Some(ref v) = self.apn_registration_id.as_ref() {
            os.write_bytes(202, &v)?;
        }
        if let Some(v) = self.notification_enabled {
            os.write_bool(203, v)?;
        }
        if let Some(ref v) = self.bluetooth_mac_address.as_ref() {
            os.write_string(302, &v)?;
        }
        if let Some(ref v) = self.device_master_key_hash.as_ref() {
            os.write_bytes(103, &v)?;
        }
        if let Some(ref v) = self.user_public_key.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.device_model.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.locale.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.key_handle.as_ref() {
            os.write_bytes(9, &v)?;
        }
        if let Some(v) = self.counter {
            os.write_int64(12, v)?;
        }
        if let Some(ref v) = self.device_os_version.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.device_os_version_code {
            os.write_int64(14, v)?;
        }
        if let Some(ref v) = self.device_os_release.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(ref v) = self.device_os_codename.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(ref v) = self.device_software_version.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(v) = self.device_software_version_code {
            os.write_int64(18, v)?;
        }
        if let Some(ref v) = self.device_software_package.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(v) = self.device_display_diagonal_mils {
            os.write_int32(22, v)?;
        }
        if let Some(v) = self.device_authzen_version {
            os.write_int32(24, v)?;
        }
        if let Some(ref v) = self.long_device_id.as_ref() {
            os.write_bytes(29, &v)?;
        }
        if let Some(ref v) = self.device_manufacturer.as_ref() {
            os.write_string(31, &v)?;
        }
        if let Some(v) = self.device_type {
            os.write_enum(32, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.using_secure_screenlock {
            os.write_bool(400, v)?;
        }
        if let Some(v) = self.auto_unlock_screenlock_supported {
            os.write_bool(401, v)?;
        }
        if let Some(v) = self.auto_unlock_screenlock_enabled {
            os.write_bool(402, v)?;
        }
        if let Some(v) = self.bluetooth_radio_supported {
            os.write_bool(403, v)?;
        }
        if let Some(v) = self.bluetooth_radio_enabled {
            os.write_bool(404, v)?;
        }
        if let Some(v) = self.mobile_data_supported {
            os.write_bool(405, v)?;
        }
        if let Some(v) = self.tethering_supported {
            os.write_bool(406, v)?;
        }
        if let Some(v) = self.ble_radio_supported {
            os.write_bool(407, v)?;
        }
        if let Some(v) = self.pixel_experience {
            os.write_bool(408, v)?;
        }
        if let Some(v) = self.arc_plus_plus {
            os.write_bool(409, v)?;
        }
        if let Some(v) = self.is_screenlock_state_flaky {
            os.write_bool(410, v)?;
        }
        for v in &self.supported_software_features {
            os.write_enum(411, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.enabled_software_features {
            os.write_enum(412, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(ref v) = self.enrollment_session_id.as_ref() {
            os.write_bytes(1000, &v)?;
        }
        if let Some(ref v) = self.oauth_token.as_ref() {
            os.write_string(1001, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcmDeviceInfo {
        GcmDeviceInfo::new()
    }

    fn default_instance() -> &'static GcmDeviceInfo {
        static instance: ::protobuf::rt::LazyV2<GcmDeviceInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcmDeviceInfo::new)
    }
}

impl ::protobuf::Clear for GcmDeviceInfo {
    fn clear(&mut self) {
        self.android_device_id = ::std::option::Option::None;
        self.gcm_registration_id.clear();
        self.apn_registration_id.clear();
        self.notification_enabled = ::std::option::Option::None;
        self.bluetooth_mac_address.clear();
        self.device_master_key_hash.clear();
        self.user_public_key.clear();
        self.device_model.clear();
        self.locale.clear();
        self.key_handle.clear();
        self.counter = ::std::option::Option::None;
        self.device_os_version.clear();
        self.device_os_version_code = ::std::option::Option::None;
        self.device_os_release.clear();
        self.device_os_codename.clear();
        self.device_software_version.clear();
        self.device_software_version_code = ::std::option::Option::None;
        self.device_software_package.clear();
        self.device_display_diagonal_mils = ::std::option::Option::None;
        self.device_authzen_version = ::std::option::Option::None;
        self.long_device_id.clear();
        self.device_manufacturer.clear();
        self.device_type = ::std::option::Option::None;
        self.using_secure_screenlock = ::std::option::Option::None;
        self.auto_unlock_screenlock_supported = ::std::option::Option::None;
        self.auto_unlock_screenlock_enabled = ::std::option::Option::None;
        self.bluetooth_radio_supported = ::std::option::Option::None;
        self.bluetooth_radio_enabled = ::std::option::Option::None;
        self.mobile_data_supported = ::std::option::Option::None;
        self.tethering_supported = ::std::option::Option::None;
        self.ble_radio_supported = ::std::option::Option::None;
        self.pixel_experience = ::std::option::Option::None;
        self.arc_plus_plus = ::std::option::Option::None;
        self.is_screenlock_state_flaky = ::std::option::Option::None;
        self.supported_software_features.clear();
        self.enabled_software_features.clear();
        self.enrollment_session_id.clear();
        self.oauth_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GcmDeviceInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GcmMetadata {
    // message fields
    field_type: ::std::option::Option<Type>,
    version: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcmMetadata {
    fn default() -> &'a GcmMetadata {
        <GcmMetadata as ::protobuf::Message>::default_instance()
    }
}

impl GcmMetadata {
    pub fn new() -> GcmMetadata {
        ::std::default::Default::default()
    }

    // required .securegcm.Type type = 1;


    pub fn get_field_type(&self) -> Type {
        self.field_type.unwrap_or(Type::ENROLLMENT)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional int32 version = 2;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0i32)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GcmMetadata {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.version {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcmMetadata {
        GcmMetadata::new()
    }

    fn default_instance() -> &'static GcmMetadata {
        static instance: ::protobuf::rt::LazyV2<GcmMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcmMetadata::new)
    }
}

impl ::protobuf::Clear for GcmMetadata {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GcmMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tickle {
    // message fields
    expiry_time: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tickle {
    fn default() -> &'a Tickle {
        <Tickle as ::protobuf::Message>::default_instance()
    }
}

impl Tickle {
    pub fn new() -> Tickle {
        ::std::default::Default::default()
    }

    // optional fixed64 expiry_time = 1;


    pub fn get_expiry_time(&self) -> u64 {
        self.expiry_time.unwrap_or(0)
    }
    pub fn clear_expiry_time(&mut self) {
        self.expiry_time = ::std::option::Option::None;
    }

    pub fn has_expiry_time(&self) -> bool {
        self.expiry_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiry_time(&mut self, v: u64) {
        self.expiry_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Tickle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.expiry_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.expiry_time {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.expiry_time {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tickle {
        Tickle::new()
    }

    fn default_instance() -> &'static Tickle {
        static instance: ::protobuf::rt::LazyV2<Tickle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tickle::new)
    }
}

impl ::protobuf::Clear for Tickle {
    fn clear(&mut self) {
        self.expiry_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Tickle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginNotificationInfo {
    // message fields
    creation_time: ::std::option::Option<u64>,
    email: ::protobuf::SingularField<::std::string::String>,
    host: ::protobuf::SingularField<::std::string::String>,
    source: ::protobuf::SingularField<::std::string::String>,
    event_type: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoginNotificationInfo {
    fn default() -> &'a LoginNotificationInfo {
        <LoginNotificationInfo as ::protobuf::Message>::default_instance()
    }
}

impl LoginNotificationInfo {
    pub fn new() -> LoginNotificationInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 creation_time = 2;


    pub fn get_creation_time(&self) -> u64 {
        self.creation_time.unwrap_or(0)
    }
    pub fn clear_creation_time(&mut self) {
        self.creation_time = ::std::option::Option::None;
    }

    pub fn has_creation_time(&self) -> bool {
        self.creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation_time(&mut self, v: u64) {
        self.creation_time = ::std::option::Option::Some(v);
    }

    // optional string email = 3;


    pub fn get_email(&self) -> &str {
        match self.email.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    pub fn has_email(&self) -> bool {
        self.email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        if self.email.is_none() {
            self.email.set_default();
        }
        self.email.as_mut().unwrap()
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        self.email.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host = 4;


    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string source = 5;


    pub fn get_source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string event_type = 6;


    pub fn get_event_type(&self) -> &str {
        match self.event_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_event_type(&mut self) {
        self.event_type.clear();
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: ::std::string::String) {
        self.event_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_type(&mut self) -> &mut ::std::string::String {
        if self.event_type.is_none() {
            self.event_type.set_default();
        }
        self.event_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_type(&mut self) -> ::std::string::String {
        self.event_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for LoginNotificationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.creation_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.source)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.event_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.creation_time {
            my_size += 9;
        }
        if let Some(ref v) = self.email.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.event_type.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.creation_time {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.email.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.event_type.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoginNotificationInfo {
        LoginNotificationInfo::new()
    }

    fn default_instance() -> &'static LoginNotificationInfo {
        static instance: ::protobuf::rt::LazyV2<LoginNotificationInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoginNotificationInfo::new)
    }
}

impl ::protobuf::Clear for LoginNotificationInfo {
    fn clear(&mut self) {
        self.creation_time = ::std::option::Option::None;
        self.email.clear();
        self.host.clear();
        self.source.clear();
        self.event_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginNotificationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AppleDeviceDiagonalMils {
    APPLE_PHONE = 4000,
    APPLE_PAD = 7900,
}

impl ::protobuf::ProtobufEnum for AppleDeviceDiagonalMils {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AppleDeviceDiagonalMils> {
        match value {
            4000 => ::std::option::Option::Some(AppleDeviceDiagonalMils::APPLE_PHONE),
            7900 => ::std::option::Option::Some(AppleDeviceDiagonalMils::APPLE_PAD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AppleDeviceDiagonalMils] = &[
            AppleDeviceDiagonalMils::APPLE_PHONE,
            AppleDeviceDiagonalMils::APPLE_PAD,
        ];
        values
    }
}

impl ::std::marker::Copy for AppleDeviceDiagonalMils {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AppleDeviceDiagonalMils {
    fn default() -> Self {
        AppleDeviceDiagonalMils::APPLE_PHONE
    }
}

impl ::protobuf::reflect::ProtobufValue for AppleDeviceDiagonalMils {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceType {
    UNKNOWN = 0,
    ANDROID = 1,
    CHROME = 2,
    IOS = 3,
    BROWSER = 4,
    OSX = 5,
}

impl ::protobuf::ProtobufEnum for DeviceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceType> {
        match value {
            0 => ::std::option::Option::Some(DeviceType::UNKNOWN),
            1 => ::std::option::Option::Some(DeviceType::ANDROID),
            2 => ::std::option::Option::Some(DeviceType::CHROME),
            3 => ::std::option::Option::Some(DeviceType::IOS),
            4 => ::std::option::Option::Some(DeviceType::BROWSER),
            5 => ::std::option::Option::Some(DeviceType::OSX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceType] = &[
            DeviceType::UNKNOWN,
            DeviceType::ANDROID,
            DeviceType::CHROME,
            DeviceType::IOS,
            DeviceType::BROWSER,
            DeviceType::OSX,
        ];
        values
    }
}

impl ::std::marker::Copy for DeviceType {
}

impl ::std::default::Default for DeviceType {
    fn default() -> Self {
        DeviceType::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SoftwareFeature {
    UNKNOWN_FEATURE = 0,
    BETTER_TOGETHER_HOST = 1,
    BETTER_TOGETHER_CLIENT = 2,
    EASY_UNLOCK_HOST = 3,
    EASY_UNLOCK_CLIENT = 4,
    MAGIC_TETHER_HOST = 5,
    MAGIC_TETHER_CLIENT = 6,
    SMS_CONNECT_HOST = 7,
    SMS_CONNECT_CLIENT = 8,
}

impl ::protobuf::ProtobufEnum for SoftwareFeature {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SoftwareFeature> {
        match value {
            0 => ::std::option::Option::Some(SoftwareFeature::UNKNOWN_FEATURE),
            1 => ::std::option::Option::Some(SoftwareFeature::BETTER_TOGETHER_HOST),
            2 => ::std::option::Option::Some(SoftwareFeature::BETTER_TOGETHER_CLIENT),
            3 => ::std::option::Option::Some(SoftwareFeature::EASY_UNLOCK_HOST),
            4 => ::std::option::Option::Some(SoftwareFeature::EASY_UNLOCK_CLIENT),
            5 => ::std::option::Option::Some(SoftwareFeature::MAGIC_TETHER_HOST),
            6 => ::std::option::Option::Some(SoftwareFeature::MAGIC_TETHER_CLIENT),
            7 => ::std::option::Option::Some(SoftwareFeature::SMS_CONNECT_HOST),
            8 => ::std::option::Option::Some(SoftwareFeature::SMS_CONNECT_CLIENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SoftwareFeature] = &[
            SoftwareFeature::UNKNOWN_FEATURE,
            SoftwareFeature::BETTER_TOGETHER_HOST,
            SoftwareFeature::BETTER_TOGETHER_CLIENT,
            SoftwareFeature::EASY_UNLOCK_HOST,
            SoftwareFeature::EASY_UNLOCK_CLIENT,
            SoftwareFeature::MAGIC_TETHER_HOST,
            SoftwareFeature::MAGIC_TETHER_CLIENT,
            SoftwareFeature::SMS_CONNECT_HOST,
            SoftwareFeature::SMS_CONNECT_CLIENT,
        ];
        values
    }
}

impl ::std::marker::Copy for SoftwareFeature {
}

impl ::std::default::Default for SoftwareFeature {
    fn default() -> Self {
        SoftwareFeature::UNKNOWN_FEATURE
    }
}

impl ::protobuf::reflect::ProtobufValue for SoftwareFeature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum InvocationReason {
    REASON_UNKNOWN = 0,
    REASON_INITIALIZATION = 1,
    REASON_PERIODIC = 2,
    REASON_SLOW_PERIODIC = 3,
    REASON_FAST_PERIODIC = 4,
    REASON_EXPIRATION = 5,
    REASON_FAILURE_RECOVERY = 6,
    REASON_NEW_ACCOUNT = 7,
    REASON_CHANGED_ACCOUNT = 8,
    REASON_FEATURE_TOGGLED = 9,
    REASON_SERVER_INITIATED = 10,
    REASON_ADDRESS_CHANGE = 11,
    REASON_SOFTWARE_UPDATE = 12,
    REASON_MANUAL = 13,
    REASON_CUSTOM_KEY_INVALIDATION = 14,
    REASON_PROXIMITY_PERIODIC = 15,
}

impl ::protobuf::ProtobufEnum for InvocationReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InvocationReason> {
        match value {
            0 => ::std::option::Option::Some(InvocationReason::REASON_UNKNOWN),
            1 => ::std::option::Option::Some(InvocationReason::REASON_INITIALIZATION),
            2 => ::std::option::Option::Some(InvocationReason::REASON_PERIODIC),
            3 => ::std::option::Option::Some(InvocationReason::REASON_SLOW_PERIODIC),
            4 => ::std::option::Option::Some(InvocationReason::REASON_FAST_PERIODIC),
            5 => ::std::option::Option::Some(InvocationReason::REASON_EXPIRATION),
            6 => ::std::option::Option::Some(InvocationReason::REASON_FAILURE_RECOVERY),
            7 => ::std::option::Option::Some(InvocationReason::REASON_NEW_ACCOUNT),
            8 => ::std::option::Option::Some(InvocationReason::REASON_CHANGED_ACCOUNT),
            9 => ::std::option::Option::Some(InvocationReason::REASON_FEATURE_TOGGLED),
            10 => ::std::option::Option::Some(InvocationReason::REASON_SERVER_INITIATED),
            11 => ::std::option::Option::Some(InvocationReason::REASON_ADDRESS_CHANGE),
            12 => ::std::option::Option::Some(InvocationReason::REASON_SOFTWARE_UPDATE),
            13 => ::std::option::Option::Some(InvocationReason::REASON_MANUAL),
            14 => ::std::option::Option::Some(InvocationReason::REASON_CUSTOM_KEY_INVALIDATION),
            15 => ::std::option::Option::Some(InvocationReason::REASON_PROXIMITY_PERIODIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [InvocationReason] = &[
            InvocationReason::REASON_UNKNOWN,
            InvocationReason::REASON_INITIALIZATION,
            InvocationReason::REASON_PERIODIC,
            InvocationReason::REASON_SLOW_PERIODIC,
            InvocationReason::REASON_FAST_PERIODIC,
            InvocationReason::REASON_EXPIRATION,
            InvocationReason::REASON_FAILURE_RECOVERY,
            InvocationReason::REASON_NEW_ACCOUNT,
            InvocationReason::REASON_CHANGED_ACCOUNT,
            InvocationReason::REASON_FEATURE_TOGGLED,
            InvocationReason::REASON_SERVER_INITIATED,
            InvocationReason::REASON_ADDRESS_CHANGE,
            InvocationReason::REASON_SOFTWARE_UPDATE,
            InvocationReason::REASON_MANUAL,
            InvocationReason::REASON_CUSTOM_KEY_INVALIDATION,
            InvocationReason::REASON_PROXIMITY_PERIODIC,
        ];
        values
    }
}

impl ::std::marker::Copy for InvocationReason {
}

impl ::std::default::Default for InvocationReason {
    fn default() -> Self {
        InvocationReason::REASON_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for InvocationReason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Type {
    ENROLLMENT = 0,
    TICKLE = 1,
    TX_REQUEST = 2,
    TX_REPLY = 3,
    TX_SYNC_REQUEST = 4,
    TX_SYNC_RESPONSE = 5,
    TX_PING = 6,
    DEVICE_INFO_UPDATE = 7,
    TX_CANCEL_REQUEST = 8,
    PROXIMITYAUTH_PAIRING = 10,
    GCMV1_IDENTITY_ASSERTION = 11,
    DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD = 12,
    DEVICE_TO_DEVICE_MESSAGE = 13,
    DEVICE_PROXIMITY_CALLBACK = 14,
    UNLOCK_KEY_SIGNED_CHALLENGE = 15,
    LOGIN_NOTIFICATION = 101,
}

impl ::protobuf::ProtobufEnum for Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Type> {
        match value {
            0 => ::std::option::Option::Some(Type::ENROLLMENT),
            1 => ::std::option::Option::Some(Type::TICKLE),
            2 => ::std::option::Option::Some(Type::TX_REQUEST),
            3 => ::std::option::Option::Some(Type::TX_REPLY),
            4 => ::std::option::Option::Some(Type::TX_SYNC_REQUEST),
            5 => ::std::option::Option::Some(Type::TX_SYNC_RESPONSE),
            6 => ::std::option::Option::Some(Type::TX_PING),
            7 => ::std::option::Option::Some(Type::DEVICE_INFO_UPDATE),
            8 => ::std::option::Option::Some(Type::TX_CANCEL_REQUEST),
            10 => ::std::option::Option::Some(Type::PROXIMITYAUTH_PAIRING),
            11 => ::std::option::Option::Some(Type::GCMV1_IDENTITY_ASSERTION),
            12 => ::std::option::Option::Some(Type::DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD),
            13 => ::std::option::Option::Some(Type::DEVICE_TO_DEVICE_MESSAGE),
            14 => ::std::option::Option::Some(Type::DEVICE_PROXIMITY_CALLBACK),
            15 => ::std::option::Option::Some(Type::UNLOCK_KEY_SIGNED_CHALLENGE),
            101 => ::std::option::Option::Some(Type::LOGIN_NOTIFICATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Type] = &[
            Type::ENROLLMENT,
            Type::TICKLE,
            Type::TX_REQUEST,
            Type::TX_REPLY,
            Type::TX_SYNC_REQUEST,
            Type::TX_SYNC_RESPONSE,
            Type::TX_PING,
            Type::DEVICE_INFO_UPDATE,
            Type::TX_CANCEL_REQUEST,
            Type::PROXIMITYAUTH_PAIRING,
            Type::GCMV1_IDENTITY_ASSERTION,
            Type::DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD,
            Type::DEVICE_TO_DEVICE_MESSAGE,
            Type::DEVICE_PROXIMITY_CALLBACK,
            Type::UNLOCK_KEY_SIGNED_CHALLENGE,
            Type::LOGIN_NOTIFICATION,
        ];
        values
    }
}

impl ::std::marker::Copy for Type {
}

impl ::std::default::Default for Type {
    fn default() -> Self {
        Type::ENROLLMENT
    }
}

impl ::protobuf::reflect::ProtobufValue for Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}
